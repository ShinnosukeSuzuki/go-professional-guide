# Go言語における配列とスライスの違い

Goでは配列(array)とスライス(slice)は似ていますが、重要な違いがあります。それぞれの特徴と違いを詳しく解説します。

## 配列（Array）

1. **固定長**：
   - 宣言時にサイズを指定し、後から変更できない
   - `var a [5]int` のように定義

2. **値型**：
   - 配列は値型（value type）
   - 関数に渡す際は値がコピーされる
   - 配列の代入は全要素のコピーが発生する

3. **メモリ割り当て**：
   - コンパイル時に固定サイズのメモリが割り当てられる
   - スタック上に確保されることが多い（小さい配列の場合）

4. **使用例**：
   ```go
   var arr [5]int                    // 要素5個の配列を宣言
   arr2 := [3]string{"Go", "Java", "Python"} // 初期化と同時に宣言
   arr3 := [...]int{1, 2, 3, 4}      // サイズを自動的に決定（この場合は4）
   ```

## スライス（Slice）

1. **可変長**：
   - 長さが動的に変更可能
   - `var s []int` のように定義（サイズ指定なし）

2. **参照型**：
   - スライスは参照型（reference type）
   - 関数に渡す際は参照が渡される（実データはコピーされない）
   - スライスの代入は参照のコピーのみ

3. **内部構造**：
   - ポインタ、長さ(length)、容量(capacity)の3つの要素を持つ
   - 実際のデータは別の場所（ヒープ上）に保存

4. **使用例**：
   ```go
   var s []int                        // 空のスライスを宣言
   s = make([]int, 5)                 // 要素5個のスライスを作成
   s = make([]int, 3, 10)             // 長さ3、容量10のスライスを作成
   s2 := []string{"Go", "Java", "Python"} // 初期化と同時に宣言
   ```

## 主な違い

### 1. メモリと性能の観点

| 特性 | 配列 | スライス |
|------|------|---------|
| メモリ割り当て | 固定長（コンパイル時） | 動的（実行時） |
| サイズ変更 | 不可 | 可能（append関数で拡張） |
| メモリ効率 | 小さいサイズの場合スタックに保持され効率的 | 参照型なのでオーバーヘッドあり |
| 大きなデータ | 大きい配列はスタックオーバーフローの可能性 | ヒープメモリを使うので大きなデータに適している |

### 2. 操作の違い

#### スライスの特有操作
1. **append**: 要素を追加する
   ```go
   s = append(s, 10, 20)
   ```

2. **capacity管理**: 容量を超えると自動的に再割り当て
   ```go
   s := make([]int, 3, 10) // 長さ3、容量10
   ```

3. **スライシング**: 部分スライスの作成
   ```go
   s2 := s[1:4] // インデックス1から3までの要素
   ```

4. **copy**: スライス間のコピー
   ```go
   copy(dst, src) // srcからdstへコピー
   ```

### 3. 使い分け

- **配列を使うべき場合**:
  - サイズが固定で変わらないことが明確な場合
  - 非常に小さなデータ構造で、効率が重要な場合
  - 値のセマンティクスが必要な場合（コピーが意図的な場合）

- **スライスを使うべき場合**:
  - 要素数が動的に変わる可能性がある場合
  - 関数に渡して中身を変更したい場合
  - ほとんどの実用的なGoプログラミングで推奨される

## サンプルコード

```go
package main

import (
	"fmt"
)

func main() {
	fmt.Println("=== 配列とスライスの基本的な違い ===")
	
	// 配列の宣言と初期化
	var arr1 [5]int
	arr2 := [3]string{"Go", "Java", "Python"}
	
	// スライスの宣言と初期化
	var slice1 []int
	slice2 := []string{"Go", "Java", "Python"}
	slice3 := make([]int, 5)      // 長さ5のスライス
	slice4 := make([]int, 3, 10)  // 長さ3、容量10のスライス
	
	fmt.Printf("arr1: %v, len: %d\n", arr1, len(arr1))
	fmt.Printf("arr2: %v, len: %d\n", arr2, len(arr2))
	fmt.Printf("slice1: %v, len: %d, cap: %d\n", slice1, len(slice1), cap(slice1))
	fmt.Printf("slice2: %v, len: %d, cap: %d\n", slice2, len(slice2), cap(slice2))
	fmt.Printf("slice3: %v, len: %d, cap: %d\n", slice3, len(slice3), cap(slice3))
	fmt.Printf("slice4: %v, len: %d, cap: %d\n", slice4, len(slice4), cap(slice4))
	
	fmt.Println("\n=== サイズの変更 ===")
	
	// 配列はサイズ変更不可
	// arr2 = [4]string{"Go", "Java", "Python", "C++"}  // コンパイルエラー
	
	// スライスは可変長
	slice2 = append(slice2, "C++")
	fmt.Printf("スライスに要素追加後: %v, len: %d, cap: %d\n", slice2, len(slice2), cap(slice2))
	
	fmt.Println("\n=== 値渡しと参照渡し ===")
	
	// 配列は値型
	arr3 := [3]int{1, 2, 3}
	arr4 := arr3  // 値のコピー
	arr4[0] = 100
	fmt.Printf("arr3: %v\n", arr3) // 元の配列は変わらない
	fmt.Printf("arr4: %v\n", arr4)
	
	// スライスは参照型
	slice5 := []int{1, 2, 3}
	slice6 := slice5  // 参照のコピー
	slice6[0] = 100
	fmt.Printf("slice5: %v\n", slice5) // 元のスライスも変わる
	fmt.Printf("slice6: %v\n", slice6)
	
	fmt.Println("\n=== 関数への渡し方の違い ===")
	
	// 配列を関数に渡す
	modify1(arr3)
	fmt.Printf("関数呼び出し後の配列: %v\n", arr3) // 変わらない
	
	// スライスを関数に渡す
	modify2(slice5)
	fmt.Printf("関数呼び出し後のスライス: %v\n", slice5) // 変わる
}

// 配列を引数に取る関数
func modify1(a [3]int) {
	a[0] = 999 // 呼び出し元には影響しない
	fmt.Printf("関数内の配列: %v\n", a)
}

// スライスを引数に取る関数
func modify2(s []int) {
	s[0] = 999 // 呼び出し元にも影響する
	fmt.Printf("関数内のスライス: %v\n", s)
}
```

## 実践的な考慮事項

1. **パフォーマンス**:
   - 配列は値型なので、大きな配列の受け渡しは非効率
   - スライスは参照型なので、大きなデータも効率的に扱える

2. **初期化**:
   - スライスのゼロ値は `nil`（`len=0, cap=0`）
   - 配列のゼロ値は全要素がゼロ値の配列

3. **一般的な慣行**:
   - Goのライブラリやほとんどのコードではスライスが使われる
   - 配列はまれにしか使われない

Goプログラミングでは、ほとんどの場合スライスを使用するのが標準的ですが、配列の特性を理解しておくことは言語の基礎として重要です。
